//trzeba ($ "") zrobić bez spacji, żeby działczyło (wszędzie)

using System.Collections.Generic;
//generyczne struktury danych- czyli mogą pracować na różnych typach danych

internal class Program
{
    public static void Main(string[] args) //metoda statyczna klasy Program//żeby użyć normalnnej metody trzeba stworzyc obiekt - add/remove/WriteLine jest metodą
    {
        int[] tab = new int[5];
        tab[0] = 3;
        tab[1] = 4;
        tab[2] = 5;
        tab[3] = 6;
        tab[4] = 7;
        Console.WriteLine(tab[4]);

        foreach (var elem in tab){
            Console.Write(elem + " ");
        }

        int[] tab2 = [1, 2, 3, 4, 5, 5, 6];
        Console.WriteLine(($ "element trzeci = {tab2[2]}"));
        //$ oznacza, że w stringu będzie jakaś nazwa zmiennej albo coś innego, która ma nie być traktowana jako tekst tylko jako wypisanie jej wartości 

  for (int i = 0; i < tab2.Length; i++)
      {
          Console.Write($ "{tab2[2]}");
      }
//////////////////////////////////////////////SŁOWNIKI      
        //SŁOWNIK ZAWSZE PRZECHOWUJE PARY klucz, wartość
        //add, remove
        
        Dictionary<string, int> dict = new Dictionary<string, int>();
        //słownik<klucz, watości>  nowy słownik w którym typem będzie string, a wartością będzie int
        //var dict = new Dictionary<string, person>();
        //jeżeli mamy klasę person to możemy ją wpisać, i będziemy pracować na typie danych danej klasy
        dict.Add("Jan", 91);
        dict.Add("Kasia", 2);
        dict.Add("Franio", 31);
        Console.WriteLine(dict);
        //wszystkie obiekty klasy dictionary są dostępne po wpisaniu dict.
        
        foreach (var elem in dict)
        {
            Console.WriteLine($ "człowiek: {elem.Key}, wiek: {elem.Value}");
        }
        //nie można użyć for, bo nie mamy przypisanych indeksów

        if (dict.ContainsKey("Jan"))
        {
            Console.WriteLine("Jan jest w słowniku");
        }
        else
        {
            Console.WriteLine("Jana w słowniku nie ma");
        }
        //to samo
        Console.WriteLine(dict.ContainsKey("Jan") ? "Jan jest w słowniku" : "Jana w słowniku nie ma");

        dict.Remove("Jan");
            
        Console.WriteLine("----------------");    
        foreach (var elem in dict)
        {
            Console.WriteLine($ "człowiek: {elem.Key}, wiek: {elem.Value}");
        }
//////////////////////////////////////////////////////////LISTY
        //w liście możemy mieć różną ilość elementów
        List<string> listaPizz = new List<string>();
        //typ obiektu przechowywanego w liście   
        //TYLKO JEDEN TYP DANYCH MOŻE BYĆ W LIŚCIE
        var ListaPizz = new List<string>();
        //T oznacza ten sam typ danych, który był wykorzystany we wcześniejszej liście
        Console.WriteLine(listaPizz.Count);
        listaPizz.Add("Margerita");
        listaPizz.Add("Pepperoni");
        listaPizz.Add("Preto");
        listaPizz.Add("Czekoladka");
        listaPizz.Add("Kebab");
        Console.WriteLine(listaPizz.Count);
        
        listaPizz.Remove("Preto");
        
        Console.WriteLine(listaPizz[1]);
        listaPizz[1] = "Super pizza";
        Console.WriteLine(listaPizz[1]);
        
        Console.WriteLine(listaPizz);

        foreach (var pizza in listaPizz)
        {
            Console.WriteLine(pizza);
        }
        Console.WriteLine("------------");
        listaPizz.ForEach(elem =>Console.WriteLine(elem));

        Console.WriteLine("Podaj swoje imię: ");
        string name = Console.ReadLine();
        Console.WriteLine($ "Cześć {name}!");
        Console.Write("Podaj swój wiek: ");
        int age = int.Parse(Console.ReadLine());
        //int się rozwala przy wpisaniu czegoś nie typu int, a bool nie
        bool isParsable = int.TryParse(Console.ReadLine(), out int yourAge);
        //out powoduje, że funkcja moze zwrócić 2 wartości, zawsze true albo false + przypisze wartość int
        Console.WriteLine(isParsable ? $ "Masz lat {age}" : "Podałeś błędny wiek");


        
    }
}
